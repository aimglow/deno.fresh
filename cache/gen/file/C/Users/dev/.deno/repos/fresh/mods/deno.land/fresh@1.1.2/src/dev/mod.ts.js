import { dirname, extname, fromFileUrl, gte, join, toFileUrl, walk } from "./deps.ts";
import { error } from "./error.ts";
const MIN_DENO_VERSION = "1.25.0";
export function ensureMinDenoVersion() {
    // Check that the minimum supported Deno version is being used.
    if (!gte(Deno.version.deno, MIN_DENO_VERSION)) {
        let message = `Deno version ${MIN_DENO_VERSION} or higher is required. Please update Deno.\n\n`;
        if (Deno.execPath().includes("homebrew")) {
            message += "You seem to have installed Deno via homebrew. To update, run: `brew upgrade deno`\n";
        } else {
            message += "To update, run: `deno upgrade`\n";
        }
        error(message);
    }
}
export async function collect(directory) {
    const routesDir = join(directory, "./routes");
    const islandsDir = join(directory, "./islands");
    const routes = [];
    try {
        const routesUrl = toFileUrl(routesDir);
        // TODO(lucacasonato): remove the extranious Deno.readDir when
        // https://github.com/denoland/deno_std/issues/1310 is fixed.
        for await (const _ of Deno.readDir(routesDir)){
        // do nothing
        }
        const routesFolder = walk(routesDir, {
            includeDirs: false,
            includeFiles: true,
            exts: [
                "tsx",
                "jsx",
                "ts",
                "js"
            ]
        });
        for await (const entry of routesFolder){
            if (entry.isFile) {
                const file = toFileUrl(entry.path).href.substring(routesUrl.href.length);
                routes.push(file);
            }
        }
    } catch (err) {
        if (err instanceof Deno.errors.NotFound) {
        // Do nothing.
        } else {
            throw err;
        }
    }
    routes.sort();
    const islands = [];
    try {
        const islandsUrl = toFileUrl(islandsDir);
        for await (const entry1 of Deno.readDir(islandsDir)){
            if (entry1.isDirectory) {
                error(`Found subdirectory '${entry1.name}' in islands/. The islands/ folder must not contain any subdirectories.`);
            }
            if (entry1.isFile) {
                const ext = extname(entry1.name);
                if (![
                    ".tsx",
                    ".jsx",
                    ".ts",
                    ".js"
                ].includes(ext)) continue;
                const path = join(islandsDir, entry1.name);
                const file1 = toFileUrl(path).href.substring(islandsUrl.href.length);
                islands.push(file1);
            }
        }
    } catch (err1) {
        if (err1 instanceof Deno.errors.NotFound) {
        // Do nothing.
        } else {
            throw err1;
        }
    }
    islands.sort();
    return {
        routes,
        islands
    };
}
export async function generate(directory, manifest) {
    const { routes , islands  } = manifest;
    const output = `// DO NOT EDIT. This file is generated by fresh.
// This file SHOULD be checked into source version control.
// This file is automatically updated during development when running \`dev.ts\`.

import config from "./deno.json" assert { type: "json" };
${routes.map((file, i)=>`import * as $${i} from "./routes${file}";`).join("\n")}
${islands.map((file, i)=>`import * as $$${i} from "./islands${file}";`).join("\n")}

const manifest = {
  routes: {
    ${routes.map((file, i)=>`${JSON.stringify(`./routes${file}`)}: $${i},`).join("\n    ")}
  },
  islands: {
    ${islands.map((file, i)=>`${JSON.stringify(`./islands${file}`)}: $$${i},`).join("\n    ")}
  },
  baseUrl: import.meta.url,
  config,
};

export default manifest;
`;
    const proc = Deno.run({
        cmd: [
            Deno.execPath(),
            "fmt",
            "-"
        ],
        stdin: "piped",
        stdout: "piped",
        stderr: "null"
    });
    const raw = new ReadableStream({
        start (controller) {
            controller.enqueue(new TextEncoder().encode(output));
            controller.close();
        }
    });
    await raw.pipeTo(proc.stdin.writable);
    const out = await proc.output();
    await proc.status();
    proc.close();
    const manifestStr = new TextDecoder().decode(out);
    const manifestPath = join(directory, "./fresh.gen.ts");
    await Deno.writeTextFile(manifestPath, manifestStr);
    console.log(`%cThe manifest has been generated for ${routes.length} routes and ${islands.length} islands.`, "color: blue; font-weight: bold");
}
export async function dev(base, entrypoint) {
    ensureMinDenoVersion();
    entrypoint = new URL(entrypoint, base).href;
    const dir = dirname(fromFileUrl(base));
    let currentManifest;
    const prevManifest = Deno.env.get("FRSH_DEV_PREVIOUS_MANIFEST");
    if (prevManifest) {
        currentManifest = JSON.parse(prevManifest);
    } else {
        currentManifest = {
            islands: [],
            routes: []
        };
    }
    const newManifest = await collect(dir);
    Deno.env.set("FRSH_DEV_PREVIOUS_MANIFEST", JSON.stringify(newManifest));
    const manifestChanged = !arraysEqual(newManifest.routes, currentManifest.routes) || !arraysEqual(newManifest.islands, currentManifest.islands);
    if (manifestChanged) await generate(dir, newManifest);
    await import(entrypoint);
}
function arraysEqual(a, b) {
    if (a.length !== b.length) return false;
    for(let i = 0; i < a.length; ++i){
        if (a[i] !== b[i]) return false;
    }
    return true;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbImZpbGU6Ly8vQzovVXNlcnMvZGV2Ly5kZW5vL3JlcG9zL2ZyZXNoL21vZHMvZGVuby5sYW5kL2ZyZXNoQDEuMS4yL3NyYy9kZXYvbW9kLnRzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIGRpcm5hbWUsXG4gIGV4dG5hbWUsXG4gIGZyb21GaWxlVXJsLFxuICBndGUsXG4gIGpvaW4sXG4gIHRvRmlsZVVybCxcbiAgd2Fsayxcbn0gZnJvbSBcIi4vZGVwcy50c1wiO1xuaW1wb3J0IHsgZXJyb3IgfSBmcm9tIFwiLi9lcnJvci50c1wiO1xuXG5jb25zdCBNSU5fREVOT19WRVJTSU9OID0gXCIxLjI1LjBcIjtcblxuZXhwb3J0IGZ1bmN0aW9uIGVuc3VyZU1pbkRlbm9WZXJzaW9uKCkge1xuICAvLyBDaGVjayB0aGF0IHRoZSBtaW5pbXVtIHN1cHBvcnRlZCBEZW5vIHZlcnNpb24gaXMgYmVpbmcgdXNlZC5cbiAgaWYgKCFndGUoRGVuby52ZXJzaW9uLmRlbm8sIE1JTl9ERU5PX1ZFUlNJT04pKSB7XG4gICAgbGV0IG1lc3NhZ2UgPVxuICAgICAgYERlbm8gdmVyc2lvbiAke01JTl9ERU5PX1ZFUlNJT059IG9yIGhpZ2hlciBpcyByZXF1aXJlZC4gUGxlYXNlIHVwZGF0ZSBEZW5vLlxcblxcbmA7XG5cbiAgICBpZiAoRGVuby5leGVjUGF0aCgpLmluY2x1ZGVzKFwiaG9tZWJyZXdcIikpIHtcbiAgICAgIG1lc3NhZ2UgKz1cbiAgICAgICAgXCJZb3Ugc2VlbSB0byBoYXZlIGluc3RhbGxlZCBEZW5vIHZpYSBob21lYnJldy4gVG8gdXBkYXRlLCBydW46IGBicmV3IHVwZ3JhZGUgZGVub2BcXG5cIjtcbiAgICB9IGVsc2Uge1xuICAgICAgbWVzc2FnZSArPSBcIlRvIHVwZGF0ZSwgcnVuOiBgZGVubyB1cGdyYWRlYFxcblwiO1xuICAgIH1cblxuICAgIGVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbmludGVyZmFjZSBNYW5pZmVzdCB7XG4gIHJvdXRlczogc3RyaW5nW107XG4gIGlzbGFuZHM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gY29sbGVjdChkaXJlY3Rvcnk6IHN0cmluZyk6IFByb21pc2U8TWFuaWZlc3Q+IHtcbiAgY29uc3Qgcm91dGVzRGlyID0gam9pbihkaXJlY3RvcnksIFwiLi9yb3V0ZXNcIik7XG4gIGNvbnN0IGlzbGFuZHNEaXIgPSBqb2luKGRpcmVjdG9yeSwgXCIuL2lzbGFuZHNcIik7XG5cbiAgY29uc3Qgcm91dGVzID0gW107XG4gIHRyeSB7XG4gICAgY29uc3Qgcm91dGVzVXJsID0gdG9GaWxlVXJsKHJvdXRlc0Rpcik7XG4gICAgLy8gVE9ETyhsdWNhY2Fzb25hdG8pOiByZW1vdmUgdGhlIGV4dHJhbmlvdXMgRGVuby5yZWFkRGlyIHdoZW5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZGVub2xhbmQvZGVub19zdGQvaXNzdWVzLzEzMTAgaXMgZml4ZWQuXG4gICAgZm9yIGF3YWl0IChjb25zdCBfIG9mIERlbm8ucmVhZERpcihyb3V0ZXNEaXIpKSB7XG4gICAgICAvLyBkbyBub3RoaW5nXG4gICAgfVxuICAgIGNvbnN0IHJvdXRlc0ZvbGRlciA9IHdhbGsocm91dGVzRGlyLCB7XG4gICAgICBpbmNsdWRlRGlyczogZmFsc2UsXG4gICAgICBpbmNsdWRlRmlsZXM6IHRydWUsXG4gICAgICBleHRzOiBbXCJ0c3hcIiwgXCJqc3hcIiwgXCJ0c1wiLCBcImpzXCJdLFxuICAgIH0pO1xuICAgIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2Ygcm91dGVzRm9sZGVyKSB7XG4gICAgICBpZiAoZW50cnkuaXNGaWxlKSB7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0b0ZpbGVVcmwoZW50cnkucGF0aCkuaHJlZi5zdWJzdHJpbmcoXG4gICAgICAgICAgcm91dGVzVXJsLmhyZWYubGVuZ3RoLFxuICAgICAgICApO1xuICAgICAgICByb3V0ZXMucHVzaChmaWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBEZW5vLmVycm9ycy5Ob3RGb3VuZCkge1xuICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICByb3V0ZXMuc29ydCgpO1xuXG4gIGNvbnN0IGlzbGFuZHMgPSBbXTtcbiAgdHJ5IHtcbiAgICBjb25zdCBpc2xhbmRzVXJsID0gdG9GaWxlVXJsKGlzbGFuZHNEaXIpO1xuICAgIGZvciBhd2FpdCAoY29uc3QgZW50cnkgb2YgRGVuby5yZWFkRGlyKGlzbGFuZHNEaXIpKSB7XG4gICAgICBpZiAoZW50cnkuaXNEaXJlY3RvcnkpIHtcbiAgICAgICAgZXJyb3IoXG4gICAgICAgICAgYEZvdW5kIHN1YmRpcmVjdG9yeSAnJHtlbnRyeS5uYW1lfScgaW4gaXNsYW5kcy8uIFRoZSBpc2xhbmRzLyBmb2xkZXIgbXVzdCBub3QgY29udGFpbiBhbnkgc3ViZGlyZWN0b3JpZXMuYCxcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChlbnRyeS5pc0ZpbGUpIHtcbiAgICAgICAgY29uc3QgZXh0ID0gZXh0bmFtZShlbnRyeS5uYW1lKTtcbiAgICAgICAgaWYgKCFbXCIudHN4XCIsIFwiLmpzeFwiLCBcIi50c1wiLCBcIi5qc1wiXS5pbmNsdWRlcyhleHQpKSBjb250aW51ZTtcbiAgICAgICAgY29uc3QgcGF0aCA9IGpvaW4oaXNsYW5kc0RpciwgZW50cnkubmFtZSk7XG4gICAgICAgIGNvbnN0IGZpbGUgPSB0b0ZpbGVVcmwocGF0aCkuaHJlZi5zdWJzdHJpbmcoaXNsYW5kc1VybC5ocmVmLmxlbmd0aCk7XG4gICAgICAgIGlzbGFuZHMucHVzaChmaWxlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBEZW5vLmVycm9ycy5Ob3RGb3VuZCkge1xuICAgICAgLy8gRG8gbm90aGluZy5cbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBpc2xhbmRzLnNvcnQoKTtcblxuICByZXR1cm4geyByb3V0ZXMsIGlzbGFuZHMgfTtcbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlKGRpcmVjdG9yeTogc3RyaW5nLCBtYW5pZmVzdDogTWFuaWZlc3QpIHtcbiAgY29uc3QgeyByb3V0ZXMsIGlzbGFuZHMgfSA9IG1hbmlmZXN0O1xuXG4gIGNvbnN0IG91dHB1dCA9IGAvLyBETyBOT1QgRURJVC4gVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBieSBmcmVzaC5cbi8vIFRoaXMgZmlsZSBTSE9VTEQgYmUgY2hlY2tlZCBpbnRvIHNvdXJjZSB2ZXJzaW9uIGNvbnRyb2wuXG4vLyBUaGlzIGZpbGUgaXMgYXV0b21hdGljYWxseSB1cGRhdGVkIGR1cmluZyBkZXZlbG9wbWVudCB3aGVuIHJ1bm5pbmcgXFxgZGV2LnRzXFxgLlxuXG5pbXBvcnQgY29uZmlnIGZyb20gXCIuL2Rlbm8uanNvblwiIGFzc2VydCB7IHR5cGU6IFwianNvblwiIH07XG4ke1xuICAgIHJvdXRlcy5tYXAoKGZpbGUsIGkpID0+IGBpbXBvcnQgKiBhcyAkJHtpfSBmcm9tIFwiLi9yb3V0ZXMke2ZpbGV9XCI7YCkuam9pbihcbiAgICAgIFwiXFxuXCIsXG4gICAgKVxuICB9XG4ke1xuICAgIGlzbGFuZHMubWFwKChmaWxlLCBpKSA9PiBgaW1wb3J0ICogYXMgJCQke2l9IGZyb20gXCIuL2lzbGFuZHMke2ZpbGV9XCI7YClcbiAgICAgIC5qb2luKFwiXFxuXCIpXG4gIH1cblxuY29uc3QgbWFuaWZlc3QgPSB7XG4gIHJvdXRlczoge1xuICAgICR7XG4gICAgcm91dGVzLm1hcCgoZmlsZSwgaSkgPT4gYCR7SlNPTi5zdHJpbmdpZnkoYC4vcm91dGVzJHtmaWxlfWApfTogJCR7aX0sYClcbiAgICAgIC5qb2luKFwiXFxuICAgIFwiKVxuICB9XG4gIH0sXG4gIGlzbGFuZHM6IHtcbiAgICAke1xuICAgIGlzbGFuZHMubWFwKChmaWxlLCBpKSA9PiBgJHtKU09OLnN0cmluZ2lmeShgLi9pc2xhbmRzJHtmaWxlfWApfTogJCQke2l9LGApXG4gICAgICAuam9pbihcIlxcbiAgICBcIilcbiAgfVxuICB9LFxuICBiYXNlVXJsOiBpbXBvcnQubWV0YS51cmwsXG4gIGNvbmZpZyxcbn07XG5cbmV4cG9ydCBkZWZhdWx0IG1hbmlmZXN0O1xuYDtcblxuICBjb25zdCBwcm9jID0gRGVuby5ydW4oe1xuICAgIGNtZDogW0Rlbm8uZXhlY1BhdGgoKSwgXCJmbXRcIiwgXCItXCJdLFxuICAgIHN0ZGluOiBcInBpcGVkXCIsXG4gICAgc3Rkb3V0OiBcInBpcGVkXCIsXG4gICAgc3RkZXJyOiBcIm51bGxcIixcbiAgfSk7XG4gIGNvbnN0IHJhdyA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKG5ldyBUZXh0RW5jb2RlcigpLmVuY29kZShvdXRwdXQpKTtcbiAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9LFxuICB9KTtcbiAgYXdhaXQgcmF3LnBpcGVUbyhwcm9jLnN0ZGluLndyaXRhYmxlKTtcbiAgY29uc3Qgb3V0ID0gYXdhaXQgcHJvYy5vdXRwdXQoKTtcbiAgYXdhaXQgcHJvYy5zdGF0dXMoKTtcbiAgcHJvYy5jbG9zZSgpO1xuXG4gIGNvbnN0IG1hbmlmZXN0U3RyID0gbmV3IFRleHREZWNvZGVyKCkuZGVjb2RlKG91dCk7XG4gIGNvbnN0IG1hbmlmZXN0UGF0aCA9IGpvaW4oZGlyZWN0b3J5LCBcIi4vZnJlc2guZ2VuLnRzXCIpO1xuXG4gIGF3YWl0IERlbm8ud3JpdGVUZXh0RmlsZShtYW5pZmVzdFBhdGgsIG1hbmlmZXN0U3RyKTtcbiAgY29uc29sZS5sb2coXG4gICAgYCVjVGhlIG1hbmlmZXN0IGhhcyBiZWVuIGdlbmVyYXRlZCBmb3IgJHtyb3V0ZXMubGVuZ3RofSByb3V0ZXMgYW5kICR7aXNsYW5kcy5sZW5ndGh9IGlzbGFuZHMuYCxcbiAgICBcImNvbG9yOiBibHVlOyBmb250LXdlaWdodDogYm9sZFwiLFxuICApO1xufVxuXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gZGV2KGJhc2U6IHN0cmluZywgZW50cnlwb2ludDogc3RyaW5nKSB7XG4gIGVuc3VyZU1pbkRlbm9WZXJzaW9uKCk7XG5cbiAgZW50cnlwb2ludCA9IG5ldyBVUkwoZW50cnlwb2ludCwgYmFzZSkuaHJlZjtcblxuICBjb25zdCBkaXIgPSBkaXJuYW1lKGZyb21GaWxlVXJsKGJhc2UpKTtcblxuICBsZXQgY3VycmVudE1hbmlmZXN0OiBNYW5pZmVzdDtcbiAgY29uc3QgcHJldk1hbmlmZXN0ID0gRGVuby5lbnYuZ2V0KFwiRlJTSF9ERVZfUFJFVklPVVNfTUFOSUZFU1RcIik7XG4gIGlmIChwcmV2TWFuaWZlc3QpIHtcbiAgICBjdXJyZW50TWFuaWZlc3QgPSBKU09OLnBhcnNlKHByZXZNYW5pZmVzdCk7XG4gIH0gZWxzZSB7XG4gICAgY3VycmVudE1hbmlmZXN0ID0geyBpc2xhbmRzOiBbXSwgcm91dGVzOiBbXSB9O1xuICB9XG4gIGNvbnN0IG5ld01hbmlmZXN0ID0gYXdhaXQgY29sbGVjdChkaXIpO1xuICBEZW5vLmVudi5zZXQoXCJGUlNIX0RFVl9QUkVWSU9VU19NQU5JRkVTVFwiLCBKU09OLnN0cmluZ2lmeShuZXdNYW5pZmVzdCkpO1xuXG4gIGNvbnN0IG1hbmlmZXN0Q2hhbmdlZCA9XG4gICAgIWFycmF5c0VxdWFsKG5ld01hbmlmZXN0LnJvdXRlcywgY3VycmVudE1hbmlmZXN0LnJvdXRlcykgfHxcbiAgICAhYXJyYXlzRXF1YWwobmV3TWFuaWZlc3QuaXNsYW5kcywgY3VycmVudE1hbmlmZXN0LmlzbGFuZHMpO1xuXG4gIGlmIChtYW5pZmVzdENoYW5nZWQpIGF3YWl0IGdlbmVyYXRlKGRpciwgbmV3TWFuaWZlc3QpO1xuXG4gIGF3YWl0IGltcG9ydChlbnRyeXBvaW50KTtcbn1cblxuZnVuY3Rpb24gYXJyYXlzRXF1YWw8VD4oYTogVFtdLCBiOiBUW10pOiBib29sZWFuIHtcbiAgaWYgKGEubGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGEubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLFNBQ0UsT0FBTyxFQUNQLE9BQU8sRUFDUCxXQUFXLEVBQ1gsR0FBRyxFQUNILElBQUksRUFDSixTQUFTLEVBQ1QsSUFBSSxRQUNDLFlBQVk7QUFDbkIsU0FBUyxLQUFLLFFBQVEsYUFBYTtBQUVuQyxNQUFNLG1CQUFtQjtBQUV6QixPQUFPLFNBQVMsdUJBQXVCO0lBQ3JDLCtEQUErRDtJQUMvRCxJQUFJLENBQUMsSUFBSSxLQUFLLE9BQU8sQ0FBQyxJQUFJLEVBQUUsbUJBQW1CO1FBQzdDLElBQUksVUFDRixDQUFDLGFBQWEsRUFBRSxpQkFBaUIsK0NBQStDLENBQUM7UUFFbkYsSUFBSSxLQUFLLFFBQVEsR0FBRyxRQUFRLENBQUMsYUFBYTtZQUN4QyxXQUNFO1FBQ0osT0FBTztZQUNMLFdBQVc7UUFDYixDQUFDO1FBRUQsTUFBTTtJQUNSLENBQUM7QUFDSCxDQUFDO0FBT0QsT0FBTyxlQUFlLFFBQVEsU0FBaUIsRUFBcUI7SUFDbEUsTUFBTSxZQUFZLEtBQUssV0FBVztJQUNsQyxNQUFNLGFBQWEsS0FBSyxXQUFXO0lBRW5DLE1BQU0sU0FBUyxFQUFFO0lBQ2pCLElBQUk7UUFDRixNQUFNLFlBQVksVUFBVTtRQUM1Qiw4REFBOEQ7UUFDOUQsNkRBQTZEO1FBQzdELFdBQVcsTUFBTSxLQUFLLEtBQUssT0FBTyxDQUFDLFdBQVk7UUFDN0MsYUFBYTtRQUNmO1FBQ0EsTUFBTSxlQUFlLEtBQUssV0FBVztZQUNuQyxhQUFhLEtBQUs7WUFDbEIsY0FBYyxJQUFJO1lBQ2xCLE1BQU07Z0JBQUM7Z0JBQU87Z0JBQU87Z0JBQU07YUFBSztRQUNsQztRQUNBLFdBQVcs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